# Prisma: one-to-many

## Model

An `Album` has many `Songs`

```ts
// api/db/schema.prisma

model Album {
  @@map("albums")

  id String @id @default(dbgenerated("public.uuid_generate_v4()")) @db.Uuid

  name String
  songs Song[]
}

model Song {
  @@map("songs")

  id String @id @default(dbgenerated("public.uuid_generate_v4()")) @db.Uuid

  albumId String @map("album_id") @db.Uuid
  album Album @relation(fields: [albumId], references: [id])
  name String
}
```

Key points
- The `one` (Album) has an array of `many` (Song)
  - `songs Song[]`
  - this does not change the database structure
- The `many` (Song) has two properties to link it to the `one` (Album)
  - `albumId String @map("album_id") @db.Uuid`
    - this adds a column `album_id` to the `songs` table
  - `album Album @relation(fields: [albumId], references: [id])`
    - this creates the relationship in typescript
    - this adds the foreign key in the database
  - in most cases you will want both properties

## Creating records

- create a new album

```ts
const magma = await db.album.create({
  data: {
    name: 'Magma',
  },
})
```
- create a new song for this album

```ts
await db.song.create({
  data: {
    name: 'The Cell',
    albumId: magma.id
  },
})
```

- create an album and all of its songs at the same time

```ts
const magma = await db.album.create({
  data: {
    name: 'Magma',
    songs: {
      create: [
        { name: 'The Shooting Star' },
        { name: 'Silvera' },
        { name: 'The Cell' },
        { name: 'Stranded' },
        { name: 'Yellow Stone' },
        { name: 'Magma' },
        { name: 'Pray' },
        { name: 'Only Pain' },
        { name: 'Low Lands' },
        { name: 'Liberation' },
      ],
    },
  },
})
```


## Querying records

- Fetch a single record from the database

```ts
// by id
const albumId = 'f08d2f7c-09af-4faa-b3ad-a6a64e164b01'
const magma = await db.album.findUnique({ where: { id: albumId } })
magma.id === albumId // => true

// by name
const magma = await db.album.findFirst({ where: { name: 'Magma' } })
magma.name === 'Magma' // => true
```

- Fetch multiple records from the database

```ts
const albums = await db.album.findMany({ where: { name: 'Magma' } })
albums.length === 1 // => true
const magma = albums.find((album) => album.name === 'Magma')
magma.name === 'Magma' // => true
albums[0] === magma // => true
```

- Fetch an album and all of its songs
  - By default associations are not loaded

```ts
const magma = await db.album.findFirst({ where: { name: 'Magma' } })
magma.songs.forEach((song) => {
  console.log(song.name)
})
//❗️ Uncaught TypeError: Cannot read properties of undefined (reading 'forEach')
magma.songs === undefined // => true
```

- Use the `include` option to load associated data

```ts
const magma = await db.album.findFirst({
  where: { name: 'Magma' }
  include: { songs: true },
})

magma.songs.forEach((song) => {
  console.log(song.name)
})
// => The Shooting Star
// => Silvera
// => ...
```

## Of interest

The Prisma client generates types for all of the database operations.

It generates the types `SongCreateInput` and `SongUncheckedCreateInput` as arguments to the song create function. If you want to pass the id of the related object (`albumId` in this case) you need to use `SongUncheckedCreateInput`;  `SongCreateInput` has an `album` property but not an `albumId`.

```ts
await db.song.create({
  data: {
    name: 'The Shooting Star',
    albumId: magma.id
  },
})
```

You would think you could use the `SongCreateInput` type with the create function like so:

```ts
await db.song.create({
  data: {
    name: 'The Shooting Star',
    album: magma,
  },
})
```

But passing an `Album` instance results in a typescript compilation error:

`Type 'Album' has no properties in common with type 'AlbumCreateNestedOneWithoutSongsInput'.`

Using `connect` will compile

```ts
await db.song.create({
  data: {
    name: 'The Shooting Star',
    album: {
      connect: magma
    }
  },
})
```

But fails at runtime

```
Invalid `db.song.create()` invocation
Argument data.album.connect of type AlbumWhereUniqueInput needs exactly one argument, but you provided id and name and bandId.

Please choose one. Available args:
type AlbumWhereUniqueInput { id?: String }
...
```

To use `SongCreateInput` type without errors you can pass the id to connect

```ts
await db.song.create({
  data: {
    name: 'The Shooting Star',
    album: {
      connect: {
        id: magma.id
      }
    }
  },
})
```

It makes more sense to just stick with the `SongUncheckedCreateInput` type instead.

I recommend checking out the types generated by Prisma client: `node_modules/.prisma/client/index.d.ts`

## Resources

- https://www.prisma.io/docs/concepts/components/prisma-schema/relations/one-to-many-relations
- https://www.prisma.io/docs/concepts/components/prisma-client/crud
